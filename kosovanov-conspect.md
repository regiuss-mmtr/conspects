### Глава 1. Рефакторинг, первый пример
Обнаружив, что в программу необходимо добавить новую функциональность, но код
программы не структурирован удобным для добавления этой функциональности образом,
сначала произведите рефакторинг программы, чтобы упростить внесение не
обходимых изменений, а только потом добавьте функцию

Перед началом рефакторинга убедитесь, что располагаете надежным комплектом
тестов. Эти тесты должны быть самопроверяющимися
Тесты важны потому, что, даже последовательно выполняя рефакторинг, необходимо исключить появление ошибок.
Время, потраченное на создание тестов, того стоит, поскольку тесты гарантируют, что можно продолжать модификацию программы

Все немодифицируемые переменные можно передавать как параметры. 
С модифицируемыми переменными сложнее. Если такая переменная только одна, ее можно вернуть из метода. 

При применении рефакторинга программа модифицируется небольшими шагами. Ошибку нетрудно обнаружить.
При рефакторинге лучше всего продвигаться маленькими шагами, чтобы не столкнуться с неприятностями.

Стоит ли заниматься переименованием? Без сомнения, стоит. Хороший код должен ясно сообщать о том, что он делает, и правильные
имена переменных составляют основу понятного кода. 
Написать код, понятный компьютеру, может каждый, но только хорошие программисты пишут код, понятный людям.

Замена временных переменных вызовами методов способствует более понятному архитектурному дизайну без длинных и сложных методов

Также вызывает беспокойство, связанное с такого вида рефакторингом, 
возможное падение производительности. Прежний код выполнял цикл while один раз,
новый код выполняет его три раза. Долго выполняющийся цикл while может снизить производительность. 
Многие программисты отказались бы от подобного рефакторинга лишь по данной причине. 
Но обратите внимание на слово «может». До проведения профилирования невозможно сказать, сколько времени требует цикл
для вычислений и происходит ли обращение к циклу достаточно часто, 
чтобы повлиять на итоговую производительность системы. Не беспокойтесь об этих вещах во время проведения рефакторинга. 
Когда вы приступите к оптимизации, тогда и нужно будет об этом беспокоиться,
но к тому времени ваше положение окажется значительно более выгодным для ее проведения и у вас будет больше возможностей 
для эффективной оптимизации

Самый важный урок, который должен преподать данный пример, это
ритм рефакторинга: тестирование, малые изменения, тестирование, малые изменения, 
тестирование, малые изменения. Именно такой ритм делает рефакторинг быстрым и надежным.

### Глава 2. Принципы рефакторинга
Рефакторинг (Refactoring) (сущ.): изменение во внутренней структуре программного обеспечения, 
имеющее целью облегчить понимание его работы и упростить модификацию, не затрагивая наблюдаемого поведения.

Производить рефакторинг (Refactor) (глаг.): изменять структуру программного обеспечения, применяя ряд рефакторингов, 
не затрагивая его поведения

цель рефакторинга – упростить понимание и модификацию программного обеспечения. 
Можно выполнить много изменений в программном обеспечении, в результате которых его видимое поведение изменится незначительно 
или вообще не изменится.
Рефакторингом будут только такие изменения, которые сделаны с
целью облегчения понимания исходного кода. Противоположным примером может служить оптимизация производительности. 
Как и рефакторинг, оптимизация производительности обычно не изменяет поведения компонента 
(за исключением скорости его работы); она лишь изменяет его внутреннее устройство. 
Цели, однако, различны. Оптимизация производительности часто затрудняет понимание кода, но
она необходима для достижения желаемого результата.

рефакторинг не меняет видимого поведения программного обеспечения. 
Оно продолжает выполнять прежние функции. Никто – ни конечный пользователь, 
ни программист – не сможет сказать по внешнему виду, что что-то изменилось.

Это второе обстоятельство связано с метафорой Кента Бека по поводу
двух видов деятельности. Применение рефакторинга при разработке
программного обеспечения разделяет время между двумя разными видами деятельности – вводом новых функций и изменением структуры.
Добавление новых функций не должно менять структуру существующего кода: просто вводятся новые возможности. 
Прогресс можно оценить, добавляя тесты и добиваясь их нормальной работы. 
При проведении рефакторинга вы стремитесь не добавлять функции, а только улучшать структуру кода. 
При этом не добавляются новые тесты (если только не обнаруживается пропущенная ранее ситуация); 
тесты изменяются только тогда, когда это абсолютно необходимо, чтобы проверить изменения в интерфейсе.
В процессе разработки программного обеспечения может оказаться необходимым часто переключаться между двумя видами работы. 
Попытавшись добавить новую функцию, можно обнаружить, что это гораздо проще сделать, если изменить структуру кода. 
Тогда следует на некоторое время переключиться на рефакторинг. 
Улучшив структуру кода, можно добавлять новую функцию. А добившись ее работы, можно заметить, что она написана способом,
затрудняющим ее понимание, тогда вы снова переключаетесь и занимаетесь рефакторингом.
Все это может происходить в течение десяти минут, но в каждый момент вы должны понимать, которым из видов работы заняты.

Чем сложнее разобраться во внутреннем устройстве кода, тем труднее его сохранить и тем быстрее происходит его распад. 
Регулярно проводимый рефакторинг помогает сохранять форму кода.

При изменении кода в некотором месте система ведет себя несоответственно расчетам, поскольку не модифицирован
другой участок, который делает то же самое, но в несколько ином контексте. 
Устраняя дублирование, мы гарантируем, что в коде есть все, что нужно, и притом только в одном месте, 
в чем и состоит суть хорошего проектирования

В конечном счете все перечисленное сводится к одному: рефакторинг способствует ускорению разработки кода.

Рефакторингом следует заниматься постоянно понемногу. Надо не решать проводить рефакторинг,
а проводить его, потому что необходимо сделать что-то еще, а поможет в этом рефакторинг.

Правило трёх ударов
Делая что-то в первый раз, вы просто это делаете.
Делая что-то аналогичное во второй раз, вы морщитесь от необходимости повторения, но все-таки повторяете то же самое. 
Делая что-то похожее в третий раз, вы начинаете рефакторинг.
"После трех ударов начинайте рефакторинг."

Из-за чего бывает трудно работать с программами? В данный момент мне приходят в голову четыре причины:
• Программы, трудные для чтения, трудно модифицировать.
• Программы, в логике которых есть дублирование, трудно модифицировать.
• Программы, которым нужны дополнительные функции, что требует изменений в работающем коде, трудно модифицировать.
• Программы, реализующие сложную логику условных операторов, трудно модифицировать.
Итак, нам нужны программы, которые легко читать, вся логика которых задана
в одном и только одном месте, модификация которых не ставит под угрозу существующие функции и которые позволяют выражать 
условную логику возможно более простым способом.
Рефакторинг представляет собой процесс улучшения работающей программы не путем изменения ее функций, 
а путем усиления в ней указанных качеств, позволяющих продолжить разработку с высокой скоростью.

Одной из областей применения рефакторинга служат базы данных.
Большинство деловых приложений тесно связано с поддерживающей
их схемой базы данных. Это одна из причин, по которым базу данных
трудно модифицировать. Другой причиной является миграция данных. 
Даже если система тщательно разбита по слоям, чтобы уменьшить зависимости между схемой базы данных и объектной моделью,
изменение схемы базы данных вынуждает к миграции данных, что может оказаться длительной и рискованной операцией.

Поменять имя метода нетрудно, если доступен весь код, вызывающий этот метод. 
Даже если метод открытый, но можно добраться до всех мест, откуда он вызывается, и модифицировать их, метод можно переименовывать.
Проблема возникает только тогда, когда интерфейс используется кодом, который не доступен для изменений.
В таких случаях интерфейс опубликован (на одну ступень дальше открытого интерфейса). 
Если интерфейс опубликован, изменять его и просто редактировать точки вызова небезопасно. 
Необходима несколько более сложная технология.

Не публикуйте интерфейсы раньше срока. Измените политику в отношении владения кодом, чтобы облегчить рефакторинг.

В некоторых случаях рефакторинг вообще не нужен. Основной пример – необходимость переписать программу с нуля.
Иногда имеющийся код настолько запутан, что подвергнуть его рефакторингу, конечно, можно, но проще начать все с самого начала.
Такое решение принять нелегко, и я признаюсь, что не могу предложить достаточно надежные рекомендации по этому поводу.
Явный признак необходимости переписать код – его неработоспособность. 
Это обнаруживается только при его тестировании, когда ошибок оказывается так много, что сделать код устойчивым не удается.
Помните, что перед началом рефакторинга код должен выполняться в основном корректно.

Рефакторинг, несомненно, заставляет программу выполняться медленнее, 
но при этом делает ее более податливой для настройки производительности. 
Секрет создания быстрых программ, если только они не предназначены для работы в жестком режиме реального времени, 
состоит в том, чтобы сначала написать программу, которую можно настраивать, 
а затем настроить ее так, чтобы достичь приемлемой скорости

### Глава 3. Код с душком
Дублирование кода
Парад дурных запахов открывает дублирующийся код. 
Увидев одинаковые кодовые структуры в нескольких местах, можно быть уверенным,
что если удастся их объединить, программа от этого только выиграет.

#### Длинный метод
Уже на заре программирования стало ясно, что чем длиннее процедура, тем труднее понять, как она работает. 
В старых языках программирования вызов процедур был связан с накладными расходами, которые удерживали от применения маленьких методов. 
Современные объектно-ориентированные языки в значительной мере устранили издержки вызовов внутри процесса. 
Однако издержки сохраняются для того, кто читает код, поскольку приходится переключать контекст,
чтобы увидеть, чем занимается процедура. Среда разработки, позво ляющая видеть одновременно два метода, помогает устранить этот
шаг, но главное, что способствует пониманию работы маленьких методов, это толковое присвоение им имен. 
Если правильно выбрать имя метода, нет необходимости изучать его тело.

#### Большой класс
Когда класс пытается выполнять слишком много работы, это часто проявляется в чрезмерном количестве имеющихся у него атрибутов.
А если класс имеет слишком много атрибутов, недалеко и до дублирования кода.

Иногда класс не использует постоянно все свои переменные экземпляра. 
В таком случае оказывается возможным применить «Выделение класса» (Extract Class, 161) 
или «Выделение подкласса» (Extract Sub&class, 330) несколько раз

Если большой класс является классом GUI, может потребоваться переместить его данные и поведение в отдельный объект 
предметной области. 
При этом может оказаться необходимым хранить копии некоторых данных в двух местах и обеспечить их согласованность. 
«Дублирование видимых данных» (Duplicate Observed Data, 197) предлагает путь, которым можно это осуществить. 
В данном случае, особенно при использовании старых компонентов Abstract Windows Toolkit (AWT), 
можно в последующем удалить класс GUI и заменить его компонентами Swing.

#### Длинный список параметров
Когда-то при обучении программированию рекомендовали все необходимые подпрограмме данные передавать в виде параметров. 
Альтернативой были глобальные переменные, а глобальные переменные пагубны и мучительны.
Благодаря объектам ситуация изменилась, т. к. если какие-то данные отсутствуют всегда можно попросить их у другого объекта. 
Поэтому, работая с объектами, следует передавать не все, что требуется методу, а столько, чтобы метод мог добраться до всех 
необходимых ему данных. 
Значительная часть того, что необходимо методу, есть в классе, которому он принадлежит. 
В объектно-ориентированных программах списки параметров обычно гораздо короче, чем в традиционных программах.
И это хорошо, потому что в длинных списках параметров трудно разбираться, они становятся противоречивыми и сложными 
в использовании, а также потому, что их приходится вечно изменять по мере того, 
как возникает необходимость в новых данных. Если передавать объекты, то изменений требуется мало, 
потому что для получения новых данных, скорее всего, хватит пары запросов

#### Расходящиеся модификации
Расходящиеся (divergent) модификации имеют место тогда, когда один класс часто модифицируется различными способами по разным причинам. 
Если, глядя на класс, вы отмечаете для себя, что эти три метода придется модифицировать для каждой новой базы данных,
а эти четыре метода придется модифицировать при каждом появлении нового финансового инструмента, это может означать, что вместо
одного класса лучше иметь два

#### «Стрельба дробью»
«Стрельба дробью» похожа на расходящуюся модификацию, но является ее противоположностью. 
Учуять ее можно, когда при выполнении любых модификаций приходится вносить множество мелких изменений в большое число классов. 
Когда изменения разбросаны повсюду, их трудно находить и можно пропустить важное изменение.

#### Завистливые функции
Весь смысл объектов в том, что они позволяют хранить данные вместе с процедурами их обработки. Классический пример дурного запаха –
метод, который больше интересуется не тем классом, в котором он находится, а каким-то другим. 
Чаще всего предметом зависти являются данные. 
Не счесть случаев, когда мы сталкивались с методом, вызывающим полдюжины методов доступа к данным другого объекта, чтобы вычислить некоторое значение. 
К счастью, лечение здесь очевидно: метод явно напрашивается на перевод в другое место, что и достигается «Перемещением метода» (Move Method, 154). 
Иногда завистью страдает только часть метода; в таком случае к завистливому фрагменту применяется «Выделение метода» (Extract Method, 124), дающее ему то, о чем он мечтает.

### Глава 4. Разработка тестов
Если посмотреть, на что уходит время у большинства программистов, то окажется, 
что на написание кода в действительности тратится весьма небольшая его часть. 
Некоторое время уходит на уяснение задачи, еще какая-то его часть – на проектирование, а львиную долю времени занимает отладка.

Делайте все тесты полностью автоматическими, так чтобы они проверяли собственные результаты

Чаще запускайте тесты. Запускайте тесты при каждой компиляции – каждый тест хотя бы раз в день.

При проведении рефакторинга выполняется лишь несколько тестов для
проверки кода, над которым вы работаете. Можно выполнять лишь
часть тестов, т. к. тестирование должно происходить быстро, в противном случае оно будет замедлять работу, 
и может возникнуть соблазн отказаться от него. Не поддавайтесь этому соблазну – возмездие неминуемо

тесты модулей (unit tests) тесно связаны с определенным местом. 
Каждый класс теста действует внутри одного пакета. 
Он проверяет интерфейсы с другими пакетами, но исходит из того, что за их пределами все работает.

Функциональные тесты (functional tests) – совсем другое дело. Их пишут для проверки работоспособности системы в целом. 
Они гаранти руют качество продукта потребителю и нисколько не заботятся о производительности программиста. 
Разрабатывать их должна отдельная команда программистов из числа таких, для которых обнаружить
ошибку – удовольствие. При этом они используют тяжеловесные инструменты и технологии.

Получив сообщение об ошибке, начните с создания теста модуля, показывающего эту ошибку

Лучше написать и выполнить неполные тесты, чем не выполнить полные тесты.

Опасение по поводу того, что тестирование не выявит все ошибки, не должно помешать написанию тестов, 
которые выявят большинство ошибок.

### Глава 5. На пути к каталогу методов рефакторинга
Поиск ссылок
Во многих методах рефакторинга требуется найти все ссылки на метод, поле или класс. 
Привлекайте для этой работы компьютер. С его помощью уменьшается риск пропустить ссылку, 
и поиск обычно выполняется значительно быстрее, чем при обычном просмотре кода.

### Глава 6. Составление методов
#### Выделение метода (Extract Method)
Преобразуйте фрагмент кода в метод, название которого объясняет его назначение.

#### Встраивание метода (Inline Method)
Поместите тело метода в код, который его вызывает, и удалите метод.
Встраивание временной переменной выполняется самостоятельно только тогда,
когда обнаруживается временная переменная, которой присваивается значение, возвращаемое вызовом метода. 
Часто эта переменная безвредна, и можно оставить ее в покое. 
Но если она мешает другим рефакторингам, например, «Выделению метода» (Extract Method), ее надо встроить.

#### Замена временной переменной вызовом метода (Replace Temp with Query)
Преобразуйте выражение в метод. Замените все ссылки на временную переменную вызовом метода. 
Новый метод может быть использован в других методах.
Проблема с этими переменными в том, что они временные и локальные. 
Поскольку они видны лишь в контексте метода, в котором используются, 
временные переменные ведут к увеличению размеров методов, потому что только так можно до них добраться. 
После замены временной переменной методом запроса получить содержащиеся в ней данные может любой метод класса. 
Это существенно содействует получению качественного кода для класса.

#### Введение поясняющей переменной (Introduce Explaining Variable)
Поместите результат выражения или его части во временную переменную, имя которой поясняет его назначение.
Выражения могут становиться очень сложными и трудными для чтения. 
В таких ситуациях полезно с помощью временных переменных превратить выражение в нечто, лучше поддающееся управлению

#### Расщепление временной переменной (Split Temporary Variable)
Имеется временная переменная, которой неоднократно присваивается значение, но это не переменная цикла и не временная переменная для
накопления результата. Создайте для каждого присваивания отдельную временную переменную.
Все переменные, выполняющие несколько функций, должны быть заменены отдельной переменной для каждой из этих функций. 
Использование одной и той же переменной для решения разных задач очень затрудняет чтение кода.

#### Удаление присваиваний параметрам (Remove Assignments to Parameters)
Код выполняет присваивание параметру. Воспользуйтесь вместо этого временной переменной.
При передаче по значению изменения параметра не отражаются в вызвавшей программе. 
Это может смутить тех, кто привык к передаче по ссылке.
Другая область, которая может вызвать замешательство, это само тело кода. 
Код оказывается значительно понятнее, если параметр используется только для представления того, 
что передано, поскольку это строгое употребление.

### Глава 7. Рефакторинг методов

• Упрощение методов: Подходы к уменьшению размера методов и повышению их читаемости.

• Извлечение методов: Выделение повторяющегося кода в отдельные методы для повышения чистоты.

Методы играют ключевую роль в создании чистого и поддерживаемого кода. 
В этой главе рассматриваются техники, позволяющие улучшить методы, такие как уменьшение их размера и повышение читаемости. 
Например, если метод выполняет несколько задач, рекомендуется выделить отдельные методы для каждой из них, что соответствует принципу единственной ответственности. 
Также важно переименовывать переменные и методы так, чтобы их названия четко отражали выполняемую функцию. 
Это значительно упрощает понимание кода и делает его более доступным для других разработчиков. 
Рефакторинг методов способствует не только улучшению структуры кода, но и повышению его тестируемости.

### Глава 8. Работа с системами

• Рефакторинг больших систем: Особенности и сложности работы с большими кодовыми базами.

• Миграция и адаптация: Как адаптировать код к новым требованиям без потери функциональности.

Работа с большими системами требует особого подхода к рефакторингу. 
В этой главе рассматриваются стратегии, позволяющие безопасно вносить изменения в сложные кодовые базы. 
Применение постепенных изменений и тестирования на каждом этапе помогает избежать серьезных ошибок. 
Миграция кода к новым требованиям должна проводиться с учетом взаимодействия между различными компонентами системы. 
Важно также обеспечить документацию изменений и поддерживать коммуникацию между командами разработчиков. 
Системный подход к рефакторингу позволяет минимизировать риски и поддерживать стабильность приложения.

### Глава 9. Культура рефакторинга

• Создание культуры: Как внедрить практику рефакторинга в команду или организацию.

• Обучение и обмен знаниями: Важность обучения команды принципам и методам рефакторинга.

Создание культуры рефакторинга в команде или организации является важным аспектом успешной разработки программного обеспечения. 
Регулярное обучение сотрудников принципам рефакторинга и обмен опытом способствует повышению качества кода. 
Внедрение практики совместного анализа кода и обсуждения лучших методов помогает создать атмосферу, 
где рефакторинг воспринимается как естественная часть рабочего процесса. Регулярные сессии по рефакторингу становятся неотъемлемой частью работы команды, 
что позволяет поддерживать высокий уровень качества и минимизировать технический долг.

### Глава 10. Заключение

• Непрерывный процесс: Рефакторинг должен стать частью повседневной практики разработки.

• Поддержание качества кода: Регулярный рефакторинг помогает поддерживать код в чистоте и готовности к изменениям

Регулярный рефакторинг помогает избежать накопления технического долга и делает код более устойчивым к изменениям в будущем. 
Важность автоматизированных тестов также не следует недооценивать, так как они обеспечивают безопасность изменений. 
Применение принципов рефакторинга способствует созданию более качественного, понятного и поддерживаемого кода, 
что в конечном итоге улучшает эффективность команды и качество продукта.